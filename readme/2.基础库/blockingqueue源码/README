â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    private final int capacity;                                     // å®¹é‡
    private final AtomicInteger count;                              // æ•°é‡é‡  ->  ç”¨æ•°é‡ï¼šcount=0ç©º
    transient LinkedBlockingQueue.Node<E> head;
    private transient LinkedBlockingQueue.Node<E> last;
    private final ReentrantLock takeLock;                           // æ¶ˆè´¹é”
    private final Condition notEmpty;                               // éç©ºæ¡ä»¶
    private final ReentrantLock putLock;                            // ç”Ÿäº§é”
    private final Condition notFull;                                // éæ»¡æ¡ä»¶

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

    public LinkedBlockingQueue() {
        this(2147483647);
    }

    public LinkedBlockingQueue(int capacity) {
        this.count = new AtomicInteger();
        this.takeLock = new ReentrantLock();
        this.notEmpty = this.takeLock.newCondition();
        this.putLock = new ReentrantLock();
        this.notFull = this.putLock.newCondition();
        if (capacity <= 0) {
            throw new IllegalArgumentException();
        } else {
            this.capacity = capacity;
            this.last = this.head = new LinkedBlockingQueue.Node((Object)null);
        }
    }

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

    public void put(E e) throws InterruptedException {
        LinkedBlockingQueue.Node<E> node = new LinkedBlockingQueue.Node(e);
        ReentrantLock putLock = this.putLock;
        AtomicInteger count = this.count;

        // ç”Ÿäº§ä»£ç åŠ é”äº’æ–¥ğŸ”’
        putLock.lockInterruptibly();

        int c;
        try {
            // å¦‚æœé˜Ÿåˆ—æ»¡äº†ï¼Œé‚£ä¹ˆè¿›å…¥æ¡ä»¶é˜»å¡
            while(count.get() == this.capacity) {
                this.notFull.await();
            }

            // å¦‚æœé˜Ÿåˆ—ä¸æ»¡ï¼Œé‚£ä¹ˆå¼€å§‹æ’å…¥æ•°æ®
            this.enqueue(node);

            // é˜Ÿåˆ—å®¹é‡+1
            c = count.getAndIncrement();

            // é˜Ÿåˆ—å®¹é‡ä¸æ»¡ä¿¡å·
            if (c + 1 < this.capacity) {
                this.notFull.signal();
            }
        } finally {
            // ç”Ÿäº§ä»£ç è§£é”
            putLock.unlock();
        }

        // å¦‚æœä¹‹å‰æ˜¯ç©ºçš„ï¼Œç°åœ¨å°±ä¸ç©ºäº†
        if (c == 0) {
            this.signalNotEmpty();
        }
    }

    private void enqueue(LinkedBlockingQueue.Node<E> node) {
        this.last = this.last.next = node;
    }

    private void signalNotEmpty() {
        ReentrantLock takeLock = this.takeLock;
        takeLock.lock();

        try {
            this.notEmpty.signal();
        } finally {
            takeLock.unlock();
        }

    }
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

    public E take() throws InterruptedException {
        AtomicInteger count = this.count;
        ReentrantLock takeLock = this.takeLock;

        // æ¶ˆè´¹é”å®šğŸ”’
        takeLock.lockInterruptibly();

        Object x;
        int c;
        try {
            // é˜Ÿåˆ—ä¸ºç©ºï¼Œé‚£ä¹ˆé˜»å¡
            while(count.get() == 0) {
                this.notEmpty.await();
            }

            // é˜Ÿåˆ—éç©ºï¼Œé‚£ä¹ˆä»é˜Ÿåˆ—ä¸­å–å‡ºå¤´éƒ¨å…ƒç´ 
            x = this.dequeue();

            // é˜Ÿåˆ—è®¡æ•°-1
            c = count.getAndDecrement();

            // é˜Ÿåˆ—éç©ºé€šçŸ¥
            if (c > 1) {
                this.notEmpty.signal();
            }
        } finally {
            takeLock.unlock();
        }

        // å¦‚æœä¹‹å‰æ˜¯æ»¡çš„ï¼Œé‚£ä¹ˆç°åœ¨takeæ“ä½œä¹‹åå°±ä¸æ»¡äº†
        if (c == this.capacity) {
            this.signalNotFull();
        }

        return x;
    }

    private E dequeue() {
        LinkedBlockingQueue.Node<E> h = this.head;
        LinkedBlockingQueue.Node<E> first = h.next;
        h.next = h;
        this.head = first;
        E x = first.item;
        first.item = null;
        return x;
    }